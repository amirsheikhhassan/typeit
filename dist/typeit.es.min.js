var defaults = {
  strings: [],
  speed: 100,
  cursor: true,
  cursorChar: "|",
  cursorSpeed: 1000,
  deleteSpeed: null,
  lifeLike: true,
  breakLines: true,
  startDelay: 250,
  startDelete: false,
  nextStringDelay: 750,
  loop: false,
  loopDelay: 750,
  html: true,
  waitUntilVisible: false,
  beforeString: () => {},
  afterString: () => {},
  beforeStep: () => {},
  afterStep: () => {},
  afterComplete: () => {}
};

/**
* Guarantees that a queue has three
* items with default values.
*
* @param {array} queueItem
* @return {array}
*/
var guaranteeThreeKeys = (q => {
  return q.map(queueItem => {
    queueItem[1] === undefined && queueItem.push(null);
    queueItem[2] === undefined && queueItem.push({});
    return queueItem;
  });
});

var merge = ((originalObj, newObj) => {
  return Object.assign({}, originalObj, newObj);
});

var isArray = (thing => {
  return Array.isArray(thing);
});

var setPropToMeta = (item, toMerge) => {
  item[2] = merge(item[2], toMerge) || toMerge;
  return item;
};

var setMetaProperty = ((queueItems, toMerge) => {
  if (!isArray(queueItems[0])) {
    return setPropToMeta(queueItems, toMerge);
  }

  return queueItems.map(i => {
    return setPropToMeta(i, toMerge);
  });
});

/**
 * Create several queue items containing a specific action. If an array is passed,
 * each item in that array will be used as the argument for the action. If a number
 * is passed, the action will be copied that many times with no argument.
 *
 * @param {integer}
 * @param {object}
 * @return {array}
 */

var queueMany = ((arrayOrNumber, actionToQueue, metaObject, shouldBookEnd) => {
  shouldBookEnd = shouldBookEnd || false;
  metaObject = metaObject || {};
  var isNumber = !isArray(arrayOrNumber);
  var totalNumberOfItems = arrayOrNumber.length;
  arrayOrNumber = isNumber ? new Array(arrayOrNumber).fill(0) : arrayOrNumber;
  return arrayOrNumber.map((item, index) => {
    if (isNumber) {
      return actionToQueue;
    }

    var queueItem = [actionToQueue, item, metaObject];

    if (shouldBookEnd) {
      // Tag as first character of arrayOrNumber for callback usage.
      if (index === 0) {
        queueItem = setMetaProperty(queueItem, {
          isFirst: true
        });
      }

      if (index + 1 === totalNumberOfItems) {
        queueItem = setMetaProperty(queueItem, {
          isLast: true
        });
      }
    }

    return queueItem;
  });
});

function Queue(initialItem) {
  var _setIdOnItems = items => {
    return guaranteeThreeKeys(items).map(step => {
      step[2] = merge(step[2], {
        id: _id
      });
      _id++;
      return step;
    });
  };
  /**
   * Insert items into the `waiting` queue.
   * @todo Can we part with this?
   *
   * @param {integer} start
   * @param {array} newItems
   */


  this.insert = function (start, newItems) {
    _queue.splice(start, 0, newItems);
  };
  /**
   * Add a single or several steps onto the `waiting` queue.
   *
   * @param {array} stepOrSteps
   * @param {boolean} toBeginning
   * @return {object}
   */


  this.add = function (stepOrSteps, numberOfTimes, toBeginning) {
    // If a single thing is passed, assume it's an action with no argument.
    stepOrSteps = isArray(stepOrSteps) ? stepOrSteps : [stepOrSteps, null];
    toBeginning = toBeginning || false;
    numberOfTimes = numberOfTimes || 1;
    var isMultipleSteps = isArray(stepOrSteps[0]);

    if (!isMultipleSteps) {
      stepOrSteps = queueMany(numberOfTimes, stepOrSteps);
    } // Set a unique ID onto each queue item added.


    stepOrSteps = _setIdOnItems(stepOrSteps);
    _queue = toBeginning ? stepOrSteps.concat(_queue) : _queue.concat(stepOrSteps);
    return this;
  };
  /**
   * Given an index, remove the last item on the `waiting` queue.
   *
   * @param {integer} index
   * @return {object}
   */


  this.delete = function (index) {
    _queue.splice(index, 1);

    return this;
  };
  /**
   * Move all `executed` queue items to `waiting`.
   *
   * @return {object}
   */


  this.reset = function () {
    _queue = _queue.map(item => {
      item[2].executed = false;
      return item;
    });
    return this;
  };
  /**
   * Retrieve all items that are still eligible to be executed.
   *
   * @return {array}
   */


  this.getItems = function () {
    _queue = guaranteeThreeKeys(_queue);
    return _queue.filter(i => {
      return !i[2].executed;
    });
  }; // this.getRawItems = function () {
  //   return _queue;
  // }

  /**
   * Given an ID for a particular queue item, update the meta on that item.
   *
   * @returns {void}
   */


  this.setMeta = function (id, meta) {
    var index = _queue.findIndex(i => i[2].id === id);

    _queue[index][2] = merge(_queue[index][2], meta);
  };

  var _queue = [];
  var _id = 0;
  this.add(initialItem);
}

/**
 * Literally just wraps toArray() to save a few bytes
 * when it's repeatedly used.
 *
 * @param {any}
 * @return {array}
 */
var toArray = (val => {
  return Array.from(val);
});

/**
 * Flatten a simple, not-deep array. Ideally, we'd be using .flat(),
 * but its browser support is not great.
 *
 * @param {array} arr
 * @return {array}
 */
var flatten = (arr => {
  var ref = [];
  return ref.concat.apply(ref, arr);
});

/**
 * Parse a string as HTML and return the body
 * of the parsed document.
 *
 * @param {string} content
 * @return {object}
 */
var getParsedBody = (content => {
  var doc = document.implementation.createHTMLDocument("");
  doc.body.innerHTML = content;
  return doc.body;
});

/**
 * Returns `true` if node is of type `text` or is a <br> element.
 *
 * @param {object} node
 * @return {boolean}
 */
var isTypeableNode = (node => {
  return node.nodeType === 3 || node.tagName === "BR";
});

/**
 * Retrieve all text/BR nodes that exist inside an element.
 */

var getAllTypeableNodes = (element, parentToExclude, shouldReverse) => {
  parentToExclude = parentToExclude || null;
  shouldReverse = shouldReverse !== undefined ? shouldReverse : false;
  var nodes = toArray(element.childNodes).map(child => {
    if (isTypeableNode(child)) {
      return child;
    }

    return getAllTypeableNodes(child);
  });
  nodes = flatten(nodes);

  if (parentToExclude) {
    nodes = nodes.filter(n => !n.parentNode.isEqualNode(parentToExclude));
  }

  return shouldReverse ? nodes.reverse() : nodes;
};

var isBodyElement = (node => {
  return node.tagName === "BODY";
});

/**
 * Given a node, generate an array of split text and nodes.
 *
 * @param {object} el
 */

var constructQueueFromNodes = el => {
  var nodeList = getAllTypeableNodes(el);
  var characterObjects = nodeList.map(item => {
    if (!item.nodeValue) {
      return createCharacterObject(item);
    }

    return toArray(item.nodeValue).map(character => {
      return createCharacterObject(character, item);
    });
  });
  return flatten(characterObjects);
};
/**
 * Construct a character object to be placed in the queue.
 * When a `null` node is passed, it's being used as a quick
 * to add a single text node to the element.
 *
 * @param {object|null} node The DOM node to which this specific character belongs.
 * @param {string} content
 * @return {object}
 */

var createCharacterObject = (content, node) => {
  node = node || null;
  var contentIsAnElement = content instanceof HTMLElement;
  return {
    // This will ALWAYS be a text node, even though
    // it may be contained in an HTML element.
    // When a node is being passed as content, this should be null.
    node,
    isTopLevelText: (!node || isBodyElement(node.parentNode)) && !contentIsAnElement,
    isHTMLElement: contentIsAnElement,
    content
  };
};
/**
 * Convert string to array of chunks that will be later
 * used to construct a TypeIt queue.
 *
 * @param {string} string
 * @return {array}
 */

function chunkStringAsHtml(string) {
  var htmlBody = getParsedBody(string);
  return constructQueueFromNodes(htmlBody);
}
/**
 * Given a string, chunk it into array items to be later
 * converted to queue items for typing.
 *
 * @param {string} str
 * @param {boolean} asHtml
 * @return {array}
 */

function maybeChunkStringAsHtml(str, asHtml) {
  asHtml = asHtml !== undefined ? asHtml : true;

  if (asHtml) {
    return chunkStringAsHtml(str);
  } // For plain strings, we still need to transform them into character objects.


  return toArray(str).map(char => {
    return createCharacterObject(char);
  });
}

var createElement = (el => {
  return document.createElement(el);
});

var appendStyleBlock = ((styles, id) => {
  var styleBlock = createElement("style");
  styleBlock.id = id || "";
  styleBlock.appendChild(document.createTextNode(styles));
  document.head.appendChild(styleBlock);
});

/**
 * Converts value as within array, unless the value itself already is one.
 *
 * @param {string} string
 * @return {array}
 */

var asArray = (string => {
  return isArray(string) ? string : [string];
});

/**
 * Given a delay value, form it into the type of object
 * that will be used by Instance().
 *
 * @param {integer | array}
 * @return {array}
 */

var calculateDelay = (delayArg => {
  if (!isArray(delayArg)) {
    delayArg = [delayArg / 2, delayArg / 2];
  }

  return {
    before: delayArg[0],
    after: delayArg[1],
    total: delayArg[0] + delayArg[1]
  };
});

var randomInRange = ((value, range) => {
  return Math.abs(Math.random() * (value + range - (value - range)) + (value - range));
});

function calculatePace (typeSpeed, deleteSpeed, lifeLike) {
  deleteSpeed = deleteSpeed !== null ? deleteSpeed : typeSpeed / 3;
  var typeRange = typeSpeed / 2;
  var deleteRange = deleteSpeed / 2;
  return lifeLike ? [randomInRange(typeSpeed, typeRange), randomInRange(deleteSpeed, deleteRange)] : [typeSpeed, deleteSpeed];
}

var destroyTimeouts = (timeouts => {
  timeouts.forEach(timeout => {
    clearTimeout(timeout);
  });
  return [];
});

var fireWhenVisible = ((element, func) => {
  var observer = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        func();
        observer.unobserve(element);
      }
    });
  }, {
    threshold: 1.0
  });
  observer.observe(element);
});

var isInput = (el => {
  return ["textarea", "input"].indexOf(el.tagName.toLowerCase()) > -1;
});

/**
 * Given a node, find the corresponding PRINTED node already in an element.
 *
 * @param {node} element
 * @param {object} element
 * @return {undefined | object}
 */

var findPrintedNode = (node, element) => {
  var printedNodes = element.querySelectorAll("*");
  return [element].concat(toArray(printedNodes).reverse()).find(i => {
    return i.cloneNode().outerHTML === node.outerHTML;
  });
};
/**
 * Determine if a given node is the _last_ child in the element.
 * This will allow us to know if we should continue typing into it,
 * or if we should create another node to append at the end.
 *
 * @param {object} node The node to check.
 * @param {object} nodeToIgnore Node to ignore.
 */

var isLastElement = (node, nodeToIgnore) => {
  if (!node) {
    return false;
  }

  var sibling = node.nextSibling;
  return !sibling || sibling.isEqualNode(nodeToIgnore);
};
/**
 * Inserts a set of content into the element. Intended for SINGLE characters.
 *
 * @param {object} element
 * @param {object} contentArg A character object.
 * @param {string | object} content
 */

var insertIntoElement = ((element, contentArg, cursorNode, cursorPosition) => {
  cursorNode = cursorNode || null;
  var contentIsElement = contentArg.isHTMLElement;
  var content = contentIsElement ? contentArg.content : document.createTextNode(contentArg.content);

  if (isInput(element)) {
    element.value = "".concat(element.value).concat(contentArg.content);
    return;
  } // We're inserting a character within an element!


  if (!contentArg.isTopLevelText && !contentIsElement) {
    var parentNode = contentArg.node.parentNode;
    var existingNode = findPrintedNode(parentNode.cloneNode(), element); // This node is already there, so keep typing into it.

    if (isLastElement(existingNode, cursorNode)) {
      element = existingNode; // Otherwise, we need to create an element!
    } else {
      // Overwrite the content with a newly created element and set the content to type.
      content = parentNode.cloneNode();
      content.innerText = contentArg.content; // This new element may be nested in ANOTHER element

      if (!isBodyElement(parentNode.parentNode)) {
        var parent = parentNode.parentNode;
        var parentClone = parent.cloneNode();
        var newElement = findPrintedNode(parentClone, element);

        while (!newElement && !isBodyElement(parent)) {
          // Wrap our element in the to-be-created parent node.
          // Then, we need to find the next candidate to print into.
          parentClone.innerHTML = content.outerHTML;
          content = parentClone;
          parentClone = parent.parentNode.cloneNode();
          parent = parent.parentNode;
          newElement = findPrintedNode(parentClone, element);
        } // We found an element before reaching the top. Assign it!


        element = newElement || element;
      }
    }
  }

  var lastNode = getAllTypeableNodes(element, cursorNode, true)[cursorPosition - 1];
  var elementToTypeInto = lastNode ? lastNode.parentNode : element; // If a cursor node exists, make sure we print BEFORE that, but only if the target
  // element actually contains it. Otherwise, stick it to the end of the element.
  // elementToTypeInto.insertBefore(
  //   content,
  //   elementToTypeInto.contains(cursorNode) ? cursorNode : null
  // );
  // console.log(content.innerText);

  elementToTypeInto.insertAdjacentHTML('beforeend', content.innerText);
});

/**
 * @param {object} HTML node
 */
var removeNode = (node => {
  var _node$parentNode;

  return node === null || node === void 0 ? void 0 : (_node$parentNode = node.parentNode) === null || _node$parentNode === void 0 ? void 0 : _node$parentNode.removeChild(node);
});

var removeComments = (element => {
  return element.innerHTML.replace(/<\!--.*?-->/g, "").trim();
});

/**
 * Given a DOM scope and selector, remove any HTML element remnants,
 * EXCEPT for <br> tags, which may be typed but do not have any text content.
 *
 * @param {object} scope
 * @param {string} selector
 * @return {void}
 */

var removeEmptyElements = (node => {
  toArray(node.querySelectorAll("*")).forEach(i => {
    if (!i.innerHTML && i.tagName !== "BR") {
      var nodeToRemove = i;

      while (nodeToRemove.parentNode.childNodes.length === 1 && // has child nodes
      nodeToRemove.parentNode.childNodes[0].isEqualNode(nodeToRemove)) {
        nodeToRemove = nodeToRemove.parentNode;
      }

      removeNode(nodeToRemove);
    }
  });
});

var repositionCursor = ((element, allChars, cursor, cursorPosition) => {
  if (!cursor) {
    return;
  }

  var characterIndex = cursorPosition; // Make sure we stop when we're at the beginning of the string.

  characterIndex = characterIndex > allChars.length ? allChars.length : characterIndex;
  var nodeToInsertBefore = allChars[characterIndex - 1];
  element = nodeToInsertBefore ? nodeToInsertBefore.parentNode : element;
  element.insertBefore(cursor, nodeToInsertBefore || null);
});

function selectorToElement (thing) {
  return typeof thing === "string" ? document.querySelector(thing) : thing;
}

var generateHash = (() => {
  return Math.random().toString().substring(2, 9);
});

var processCursorMovementArg = ((movementArg, currentCursorPosition, allChars) => {
  var isString = typeof movementArg === "string";
  var isMovingToEnd;
  var canKeepMoving = false;
  var numberOfSteps = movementArg * -1;

  if (isString) {
    isMovingToEnd = movementArg.toUpperCase() === "END";
    numberOfSteps = isMovingToEnd ? -1 : 1;
    canKeepMoving = isMovingToEnd ? currentCursorPosition + numberOfSteps > 0 : currentCursorPosition + numberOfSteps < allChars.length;
  }

  return {
    isString,
    numberOfSteps,
    canKeepMoving
  };
});

var getComputedStyle = (el => {
  return window.getComputedStyle(el, null);
});

var getStyleString = (fromElement => {
  var stylePrefixes = ["font", "lineHeight", "color"];
  var dummyElement = createElement("SPAN");
  var styles = getComputedStyle(fromElement);

  for (var key in styles) {
    if (stylePrefixes.indexOf(key) > -1 && styles[key]) {
      dummyElement.style[key] = styles[key];
    }
  }

  return dummyElement.style.cssText;
});

function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

function _empty2() {}

function _awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(_empty2) : Promise.resolve();
  }
}

function _invoke(body, then) {
  var result = body();

  if (result && result.then) {
    return result.then(then);
  }

  return then(result);
}

function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}

var _Pact = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}();

function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}

function _forTo(array, body, check) {
  var i = -1,
      pact,
      reject;

  function _cycle(result) {
    try {
      while (++i < array.length && (!check || !check())) {
        result = body(i);

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }

      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle(pact || (pact = new _Pact()), 2, e);
    }
  }

  _cycle();

  return pact;
}

function _continue(value, then) {
  return value && value.then ? value.then(then) : then(value);
}

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function TypeIt(element, options) {
  var _this = this;

  options = options || {};

  var _maybeAppendPause = opts => {
    opts = opts || {};
    var delay = opts.delay;
    delay && _queue.add([_pause, delay]);
  };

  var _queueAndReturn = (stepOrSteps, numberOfTimes, opts) => {
    stepOrSteps = isArray(stepOrSteps[0]) ? stepOrSteps : [stepOrSteps];

    _queue.add(stepOrSteps, numberOfTimes);

    _maybeAppendPause(opts);

    return this;
  };

  var _generateTemporaryOptionQueueItems = newOptions => {
    newOptions = typeof newOptions === "object" ? newOptions : {};
    return [[_options, newOptions, {
      force: true
    }], [_options, _opts, {
      force: true
    }]];
  };
  /**
   * Get a flattened array of text nodes that have been typed.
   * This excludes any cursor character that might exist.
   *
   * @return {array}
   */


  var _getAllChars = () => {
    if (_elementIsInput) {
      return toArray(_element.value);
    }

    return getAllTypeableNodes(_element, _cursor, true);
  };
  /**
   * Insert a split pause around a range of queue items.
   *
   * @param  {Number} startPosition The array position at which to start wrapping.
   * @param  {Number} numberOfActionsToWrap The number of actions in the queue to wrap.
   * @return {void}
   */


  var _addSplitPause = (startPosition, numberOfActionsToWrap) => {
    numberOfActionsToWrap = numberOfActionsToWrap || 1;
    var delay = _opts.nextStringDelay;

    _queue.insert(startPosition, [_pause, delay.before]);

    _queue.insert(startPosition + numberOfActionsToWrap + 1, [_pause, delay.after]);
  };
  /**
   * Provided it's a non-form element and the options is provided,
   * set up the cursor element for the
   *
   * @return {void}
   */


  var _setUpCursor = () => {
    if (_elementIsInput || !_opts.cursor) {
      return null;
    } // If we have a cursor node from a previous instance (prior to a reset()),
    // there's no need to recreate one now.


    var cursor = createElement("span");
    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;
    cursor.className = "ti-cursor";
    cursor.style.cssText = "display:inline;".concat(getStyleString(_element));
    return cursor;
  };
  /**
   * If a cursor node's been generated, attach it to the DOM so
   * it appears for the user, along with the required CSS transition.
   *
   * @return void
   */


  var _maybeAttachCursor = _async(function () {
    if (!_cursor) {
      return;
    }

    var selector = "[data-typeit-id='".concat(_id, "'] .ti-cursor");
    appendStyleBlock("@keyframes blink-".concat(_id, " { 0% {opacity: 0} 49% {opacity: 0} 50% {opacity: 1} } ").concat(selector, " { animation: blink-").concat(_id, " ").concat(_opts.cursorSpeed / 1000, "s infinite; } ").concat(selector, ".with-delay { animation-delay: 500ms; } ").concat(selector, ".disabled { animation: none; }"), _id);

    _element.appendChild(_cursor);

    var _temp = document.fonts.status === "loaded";

    return _await(_temp || document.fonts.ready, function (_document$fonts$ready) {
      var calculatedMargin = _cursor.getBoundingClientRect().width / 2;
      _cursor.style.margin = "0 -".concat(calculatedMargin + 2, "px 0 -").concat(calculatedMargin - 2, "px");
    }, _temp);
  });

  var _disableCursorBlink = shouldDisable => {
    if (!_cursor) {
      return;
    }

    _cursor.classList.toggle("disabled", shouldDisable);

    _cursor.classList.toggle("with-delay", !shouldDisable);
  };
  /**
   * Fire a callback after a delay, adding the created timeout
   * to the `timeouts` instance property.
   *
   * @param {object} callback
   * @param {integer} delay
   */


  var _wait = _async(function (callback, delay) {
    _timeouts.push(setTimeout(callback, delay));

    return _await();
  });
  /**
   * Based on provided strings, generate a TypeIt queue
   * to be fired for each character in the string.
   *
   * @param {array|null} initialStep
   */


  var _generateQueue = () => {
    var strings = _opts.strings.filter(string => !!string);

    strings.forEach((string, index) => {
      var chunkedString = maybeChunkStringAsHtml(string, _opts.html);

      _queue.add(queueMany(chunkedString, _type, _freezeCursorMeta, true));

      var queueLength = _queue.getItems().length; // This is the last string. Get outta here.


      if (index + 1 === strings.length) {
        return;
      }

      if (_opts.breakLines) {
        var breakObj = createCharacterObject(createElement("BR"));

        _queue.add([_type, breakObj, _freezeCursorMeta]);

        _addSplitPause(queueLength);

        return;
      }

      _queue.add(queueMany(chunkedString, _delete, _freezeCursorMeta));

      _addSplitPause(queueLength, string.length);
    });
  };
  /**
   * 1. Reset queue.
   * 2. Remove initial pause.
   * 3. Add phantom deletions.
   */


  var _loopify = _async(function (delay) {
    // Reset queue.
    // Remove initial pause, so we can replace with `loop` pause.
    // Add delay pause FIRST, since we're adding to beginning of queue.
    // Reset the cursor position!
    return _invoke(function () {
      if (_cursorPosition) {
        return _awaitIgnored(_move(_cursorPosition));
      }
    }, function () {
      _queue.reset().delete(0).add([_pause, delay.before], 1, true); // Queue the current number of printed items for deletion.


      _getAllChars().forEach(i => {
        _queue.add([_delete, null, {
          isPhantom: true
        }], 1, true);
      });
    });
  });

  var _maybePrependHardcodedStrings = strings => {
    var existingMarkup = removeComments(_element);

    if (!existingMarkup) {
      return strings;
    } // Once we've saved the existing markup to a variable,
    // wipe the element clean to prepare for typing.


    _element.innerHTML = "";

    if (_opts.startDelete) {
      chunkStringAsHtml(existingMarkup).forEach(item => {
        insertIntoElement(_element, item, _cursor, _cursorPosition);
      });

      _queue.add([_delete, true]);

      _addSplitPause(1);

      return strings;
    }

    return [existingMarkup.trim()].concat(strings);
  };

  var _fire = _async(function () {
    var _exit = false;
    _statuses.started = true;

    var queueItems = _queue.getItems();

    var callbackArgs;
    return _continue(_catch(function () {
      return _continue(_forTo(queueItems, function (i) {
        if (_statuses.frozen || _statuses.destroyed) {
          throw "";
        }

        var queueAction = queueItems[i];
        var queueActionMeta = queueAction[2];
        callbackArgs = [queueAction, _this];
        queueActionMeta.freezeCursor && _disableCursorBlink(true);
        _pace = calculatePace(_opts.speed, _opts.deleteSpeed, _opts.lifeLike);
        return _invoke(function () {
          if (queueActionMeta === null || queueActionMeta === void 0 ? void 0 : queueActionMeta.isFirst) {
            var _opts2;

            return _awaitIgnored((_opts2 = _opts).beforeString.apply(_opts2, callbackArgs));
          }
        }, function () {
          var _opts3;

          return _await((_opts3 = _opts).beforeStep.apply(_opts3, callbackArgs), function () {
            // Fire this step! During this process, pluck items from the waiting
            // queue and move them to executed.
            return _await(queueAction[0].call(_this, queueAction[1], queueActionMeta), function () {
              // If this is a phantom item, as soon as it's executed,
              // remove it from the queue and pretend it never existed.
              return _invoke(function () {
                if (!queueActionMeta || !queueActionMeta.isPhantom) {
                  return _invoke(function () {
                    var _queueAction$;

                    if ((_queueAction$ = queueAction[2]) === null || _queueAction$ === void 0 ? void 0 : _queueAction$.isLast) {
                      var _opts4;

                      return _awaitIgnored((_opts4 = _opts).afterString.apply(_opts4, callbackArgs));
                    }
                  }, function () {
                    var _opts5;

                    return _await((_opts5 = _opts).afterStep.apply(_opts5, callbackArgs), function () {
                      _queue.setMeta(queueActionMeta.id, {
                        executed: true
                      });
                    });
                  });
                }
              }, function () {
                _disableCursorBlink(false);
              });
            });
          });
        });
      }, function () {
        return _exit;
      }), function (_result) {
        var _opts6;

        if (_exit) return _result;
        _statuses.completed = true;
        return _await((_opts6 = _opts).afterComplete.apply(_opts6, callbackArgs), function () {
          if (_opts.loop) {
            var delay = _opts.loopDelay;

            _wait(function () {
              return _await(_loopify(delay), function () {
                _fire();
              });
            }, delay.after);
          }
        });
      });
    }, _empty2), function (_result2) {
      return  _this;
    });
  });

  var _pause = time => {
    return new Promise(resolve => {
      _wait(() => {
        return resolve();
      }, time || 0);
    });
  };
  /**
   * Move type cursor by a given number.
   *
   * @param {integer} movementArg
   */


  var _move = movementArg => {
    var allChars = _getAllChars();

    var arg = processCursorMovementArg(movementArg, _cursorPosition, allChars);
    _cursorPosition += arg.numberOfSteps;
    return new Promise(resolve => {
      _wait(_async(function () {
        repositionCursor(_element, _getAllChars(), _cursor, _cursorPosition);
        /**
         * If our argument is a string, we're moving absolutely and need to keep
         * going until there are no more spaces to move.
         */

        return _invoke(function () {
          if (arg.isString && arg.canKeepMoving) {
            return _awaitIgnored(_move(arg.numberOfSteps > 0 ? "START" : "END"));
          }
        }, function () {
          return resolve();
        });
      }), _pace[0]);
    });
  };

  var _type = characterObject => {
    return new Promise(resolve => {
      _wait(() => {
        insertIntoElement(_element, characterObject, _cursor, _cursorPosition);
        return resolve();
      }, _pace[0]);
    });
  };

  var _options = _async(function (opts) {
    _opts = merge(_opts, opts);
  });

  var _empty = _async(function () {
    if (_elementIsInput) {
      _element.value = "";
      return;
    }

    _getAllChars().forEach(n => {
      removeNode(n);
    });
  });

  var _delete = keepGoingUntilAllIsGone => {
    keepGoingUntilAllIsGone = keepGoingUntilAllIsGone === true;
    return new Promise(resolve => {
      _wait(_async(function () {
        var _exit2 = false;

        var allChars = _getAllChars();

        if (allChars.length) {
          if (_elementIsInput) {
            _element.value = _element.value.slice(0, -1);
          } else {
            removeNode(allChars[_cursorPosition]);
          }
        }

        removeEmptyElements(_element);
        /**
         * If it's specified, keep deleting until all characters are gone. This is
         * the only time when a SINGLE queue action (`delete()`) deals with multiple
         * characters at once. I don't like it, but need to implement like this right now.
         */

        return _invoke(function () {
          if (keepGoingUntilAllIsGone && allChars.length - 1 > 0) {
            return _await(_delete(true), function () {
              _exit2 = true;
              return resolve();
            });
          }
        }, function (_result3) {
          return _exit2 ? _result3 : resolve();
        });
      }), _pace[1]);
    });
  };

  this.break = function (actionOpts) {
    return _queueAndReturn([_type, createCharacterObject(createElement("BR"))], 1, actionOpts);
  };

  this.delete = function (numCharacters, actionOpts) {
    var bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);

    return _queueAndReturn([bookEndQueueItems[0]].concat([].concat(Array(Math.abs(numCharacters) || 1)).fill().map(() => [_delete, !numCharacters, _freezeCursorMeta]), [bookEndQueueItems[1]]), 1, actionOpts);
  };

  this.empty = function () {
    return _queueAndReturn(_empty, 1, arguments);
  };

  this.exec = function (func, actionOpts) {
    var bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);

    return _queueAndReturn([bookEndQueueItems[0], [func, null], bookEndQueueItems[1]], 1, actionOpts);
  };

  this.move = function (movementArg, actionOpts) {
    var arg = processCursorMovementArg(movementArg, _cursorPosition, _getAllChars());

    var bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);

    var moveArg = arg.isString ? movementArg : Math.sign(movementArg);
    return _queueAndReturn([bookEndQueueItems[0]].concat([].concat(Array(Math.abs(movementArg) || 1)).fill().map(() => [_move, moveArg, _freezeCursorMeta]), [bookEndQueueItems[1]]), 1, actionOpts);
  };

  this.options = function (opts) {
    return _queueAndReturn([_options, opts], 1, opts);
  };

  this.pause = function (ms, actionOpts) {
    return _queueAndReturn([_pause, ms], 1, actionOpts);
  };

  this.type = function (string, actionOpts) {
    var bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);

    var chunkedString = maybeChunkStringAsHtml(string, _opts.html);
    var itemsToQueue = [bookEndQueueItems[0]].concat(queueMany(chunkedString, _type, _freezeCursorMeta, true), [bookEndQueueItems[1]]);
    return _queueAndReturn(itemsToQueue, 1, actionOpts);
  };

  this.is = function (key) {
    return _statuses[key];
  };

  this.destroy = function (shouldRemoveCursor) {
    shouldRemoveCursor = shouldRemoveCursor === undefined ? true : shouldRemoveCursor;
    _timeouts = destroyTimeouts(_timeouts);
    shouldRemoveCursor && removeNode(_cursor);
    _statuses.destroyed = true;
  };

  this.freeze = function () {
    _statuses["frozen"] = true;
  };

  this.unfreeze = function () {
    _statuses["frozen"] = false;

    _fire();
  };

  this.reset = function () {
    !this.is("destroyed") && this.destroy();

    _queue.reset();

    _cursorPosition = 0;

    for (var property in _statuses) {
      _statuses[property] = false;
    }

    _elementIsInput ? _element.value = "" : _element.innerHTML = "";
    return this;
  };

  this.go = function () {
    if (_statuses.started) {
      return this;
    }

    _maybeAttachCursor();

    if (!_opts.waitUntilVisible) {
      _fire();

      return this;
    }

    fireWhenVisible(_element, _fire.bind(this));
    return this;
  };

  this.getQueue = function () {
    return _queue;
  };

  this.getOptions = function () {
    return _opts;
  };

  this.getElement = function () {
    return _element;
  };

  var _element = selectorToElement(element);

  var _elementIsInput = isInput(_element);

  var _pace = [];
  var _timeouts = [];
  var _cursorPosition = 0;
  var _freezeCursorMeta = {
    freezeCursor: true
  };
  var _statuses = {
    started: false,
    completed: false,
    frozen: false,
    destroyed: false
  };

  var _opts = merge(defaults, options);

  _opts = merge(_opts, {
    html: _elementIsInput ? false : _opts.html,
    nextStringDelay: calculateDelay(_opts.nextStringDelay),
    loopDelay: calculateDelay(_opts.loopDelay)
  });

  var _id = generateHash();

  var _queue = new Queue([_pause, _opts.startDelay]);

  _element.setAttribute("data-typeit-id", _id); // Used to set a "placeholder" space in the element, so that it holds vertical sizing before anything's typed.


  appendStyleBlock("[data-typeit-id]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}[data-typeit-id]");
  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));

  var _cursor = _setUpCursor(); // Only generate a queue if we have strings
  // and this isn't a reset of a previous instance,
  // in which case we'd have a pre-defined queue.


  if (_opts.strings.length) {
    _generateQueue();
  }
}

export default TypeIt;
